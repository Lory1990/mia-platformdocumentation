---
id: node_ms_tutorial
title: Create a Microservice
sidebar_label: Create a Microservice
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import SourceCodeBlock from "./../../../src/components/SourceCodeBlock";

In this tutorial, we will see how to create and develop a new microservice starting from the [templates](/marketplace/templates/mia_templates.md), offered by the [Mia-Platform Marketplace](/marketplace/overview_marketplace.md), up to the actual coding of the endpoints. We will also deep dive into the functionalities that Mia-Platform Console offers to the developer during all the process of development.

## What we will Build

We will develop a simple **microservice that exposes a route** that returns the shipping cost depending on whether the user is a new customer or not. More precisely, the values returned by the API will be based on the value of some [environment variable](/development_suite/set-up-infrastructure/env-var-intro.md).

We will also create a CRUD service to store the data related to the customers and orders, and we will see how to communicate between different services, the one we are developing and the _curd-service_.

In the final part, we will go over how to check the logs and status of the services, and how to release the final version into production using semantic versioning.

## Prerequisites

Before starting, we will assume that, you already have a clean project in Mia-Platform Console. To know how to create a project on Mia-Platform Console, read [this guide](/development_suite/set-up-infrastructure/create-project.mdx).

The project must:

- Be integrated with a [deploy pipeline](/development_suite/deploy/pipeline-configuration.md);
- Have an [ingress route](/paas/traefik.md) with "api-gateway" as `service`;
- Be aware of have configured your project domain to be called. If the project links have been configured, you can find them in the "Environments" section of the "Project Settings", under the "Application" column;
- Have a properly configured API Portal.

Better to have:

- Some familiarity with **API** and **REST** concepts. More information about API is available [here](/guidelines/rest_api_vademecum.md).

:::tip
If your are using a Mia-Platform Console in PaaS and the project has been created using the "Mia-Platform Basic Project Template", the project is already configured as needed.
:::

## Create CRUDs

Firstly, open your project, and create the following [MongoDB CRUD](/development_suite/api-console/api-design/crud_advanced.md) collections:

- Create `customers` CRUD collection, download the schema <a download target="_blank" href="/docs_files_to_download/tutorial/node_ms/customers.json">here</a> or copy it from below;

  <details>
    <summary>Click to see the customers schema:</summary>
    <p>
      <SourceCodeBlock filePath="/docs_files_to_download/tutorial/node_ms/customers.json" />
    </p>
  </details>

- Create `orders` CRUD collection, download the schema <a download target="_blank" href="/docs_files_to_download/tutorial/node_ms/orders.json">here</a> or copy it from below.

  <details>
    <summary>Click to see the orders schema:</summary>
    <p>
      <SourceCodeBlock filePath="/docs_files_to_download/tutorial/node_ms/orders.json" />
    </p>
  </details>

:::info
You don't know how to import CRUD schema? Give a look [here](/tutorial/rest_api/quick_rest_api.mdx#option-2-import-crud-collection)
:::

### Expose CRUD

Once the collections have been created, they need to be exposed through an [Endpoint](/development_suite/endpoint-overview/endpoint-overview.md).

1. Create `customers` CRUD endpoint:

   - **Base path**: `/customers`;
   - **Type**: in the dropdown menu, select `"CRUD"`;
   - **CRUD Base Path**: in the dropdown menu, select `/customers`.

1. Create `orders` CRUD endpoint:

   - **Base path**: `/orders`;
   - **Type**: in the dropdown menu, select `"CRUD"`;
   - **CRUD Base Path**: in the dropdown menu, select `/orders`.

:::info
You don't know how to import CRUD schema? Give a look [here](/tutorial/rest_api/quick_rest_api.mdx#expose-the-crud-using-an-endpoint)
:::

## Create the Microservice from the Marketplace Template

A Microservice can be created starting from existing Templates. Starting from a Mia-Platform Template or using Mia-Platform Service Libraries has many advantages and allows your microservice to be compliant with all best practices (such as pipelines, [logging](#logging), [health routes](#health-routes), etc.).

In the [Marketplace](/marketplace/overview_marketplace.md) you can find a list of Examples or Templates powered and supported by Mia-Platform that allows you to set up microservices with a tested and pre-defined function.

<Tabs
  defaultValue="js"
  groupId="microservice-tutorial-language"
  values={[
      { label: 'Node.js', value: 'js', },
      { label: 'Java', value: 'java', },
  ]}
>
<TabItem value="js">

We will create a microservice from [Node.js template](https://github.com/mia-platform-marketplace/Node.js-Custom-Plugin-Template/):

1. Go to [Microservices](/development_suite/api-console/api-design/services.md) section and click _Create a Microservice_;
1. Search the template `Node.js Template`, then select it;
1. Now enter the following information:

   - **Name**: `shipping-cost`;

1. In the detail, go to the _Microservice configuration_ section and set **Memory Request Limit** to `150` and **CPU Limit** to `100`.

</TabItem>
<TabItem value="java">

We will create a microservice from [Java Springboot template](https://github.com/mia-platform-marketplace/SpringBoot-Custom-Plugin-Template/):

1. Go to [Microservices](/development_suite/api-console/api-design/services.md) section and click _Create a Microservice_;
1. Search the template `Springboot Template`, then select it;
1. Now enter the following information:

   - **Name**: `shipping-cost`;

1. In the detail, go to the _Microservice configuration_ section and set **Memory Request Limit** to `150` and **CPU Limit** to `100`.

</TabItem>
</Tabs>

Now you have to expose the microservice:

1. Go to [Endpoints](/development_suite/api-console/api-design/endpoints.md) section and click _Create new endpoint_. Then enter the following information:

   - **Base path**: `/shipping-cost-service`;
   - **Type**: in the dropdown menu select `"Microservice"`;
   - **Microservice**: in the dropdown menu select `shipping-cost`.

1. Click _Create_ button;
1. Commit the changes.

:::info
If you have difficulty creating the microservice or exposing it, check out the [first tutorial](/tutorial/microservices/hello_world.mdx)!
:::

## Let's code!

The newly created microservice repository can be accessed from the microservice details page, by clicking on _View Repository_ button in the upper right-corner. The _Clone_ button allows you to easily see SSH and HTTPS urls to clone the repository in your local machine or to directly open it with your preferred editor.

Now, we want to implement the route that calculates the shipping cost. We could have started by writing the code first, but Mia-Platform strongly encourages the use of [Test Driven Development](https://en.wikipedia.org/wiki/Test-driven_development?oldformat=true).  
This approach allows the developer to focus on the needed requirements and, in addition, makes the code easier to evolve over time and durable to mistakes.

### Write the tests

That said, let's start writing a simple test for `GET /shipping-cost` route. It will receive an `email` in the query string as the customer identifier and return the correct shipping cost.

<Tabs
  defaultValue="js"
  groupId="microservice-tutorial-language"
  values={[
      { label: 'Node.js', value: 'js', },
      { label: 'Java', value: 'java', },
  ]}
>
<TabItem value="js">

As the first thing to do open the `test/index.test.js` file and add on the top, after the requirements, the [Nock](https://github.com/nock/nock) module to mocks the call to the CRUD simulating responses from HTTP requests. The `nock.disableNetConnect()` callback indeed disable the real HTTP requests to avoid unwanted calls.

After that let's write the real test, replacing the "Insert your tests" comment with the highlighted code:

```js {5-6,30-59}
"use strict";

const t = require("tap");
const lc39 = require("@mia-platform/lc39");
const nock = require("nock");
nock.disableNetConnect();

async function setupFastify(envVariables) {
  const fastify = await lc39("./index.js", {
    logLevel: "silent",
    envVariables,
  });
  return fastify;
}

t.test("shipping-cost", async (t) => {
  // silent => trace for enabling logs
  const fastify = await setupFastify({
    USERID_HEADER_KEY: "userid",
    GROUPS_HEADER_KEY: "groups",
    CLIENTTYPE_HEADER_KEY: "clienttype",
    BACKOFFICE_HEADER_KEY: "backoffice",
    MICROSERVICE_GATEWAY_SERVICE_NAME: "microservice-gateway.example.org",
  });

  t.teardown(async () => {
    await fastify.close();
  });

  t.test("Default customer shipping cost", async (t) => {
    const NEW_CUSTOMER_SHIPPING_COST = 5.99;
    const DEFAULT_SHIPPING_COST = 10;
    const CRUD_BASE_URL = "http://crud-service";
    const getCustomerScope = nock(CRUD_BASE_URL)
      .get(`/customers/`)
      .query({ email: mockedCustomer.email })
      .reply(200, [mockedCustomer]);

    const getOrderScope = nock(CRUD_BASE_URL)
      .get(`/orders/count`)
      .query({ customerId: mockedCustomer._id })
      .reply(200, 1);

    const response = await fastify.inject({
      method: "GET",
      url: "/shipping-cost",
      query: {
        customerEmail: mockedCustomer.email,
      },
    });
    t.equal(response.statusCode, 200);
    t.same(JSON.parse(response.payload), {
      shippingCost: DEFAULT_SHIPPING_COST,
    });

    // Check if the mocked requests have been really called by the handler
    getOrderScope.done();
    getCustomerScope.done();
  });

  t.end();
});
```

In this test we tested only the "happy path," that is, returning the correct shipping cost for a new customer. To achieve full coverage by testing the inputs and the return of the default shipping cost you need to write more tests, so if you want to try that or just copy the complete test code below:

<details><summary>Tests to get full coverage:</summary>
<p>

```js title=/tests/index.test.js
"use strict";

const t = require("tap");
const lc39 = require("@mia-platform/lc39");
const nock = require("nock");
nock.disableNetConnect();

async function setupFastify(envVariables) {
  const fastify = await lc39("./index.js", {
    logLevel: "silent",
    envVariables,
  });
  return fastify;
}

const NEW_CUSTOMER_SHIPPING_COST = 5.99;
const DEFAULT_SHIPPING_COST = 10;
const CRUD_BASE_URL = "http://crud-service";

t.test("shipping-cost", async (t) => {
  // silent => trace for enable logs
  const fastify = await setupFastify({
    USERID_HEADER_KEY: "userid",
    GROUPS_HEADER_KEY: "groups",
    CLIENTTYPE_HEADER_KEY: "clienttype",
    BACKOFFICE_HEADER_KEY: "backoffice",
    MICROSERVICE_GATEWAY_SERVICE_NAME: "microservice-gateway.example.org",
  });

  t.teardown(async () => {
    await fastify.close();
  });

  t.test("GET /shipping-cost", (t) => {
    const customerId = "1";

    const mockedCustomer = {
      _id: customerId,
      email: "customer@email.com",
    };

    t.test("404 - No customer found", async (t) => {
      const getCustomerScope = nock(CRUD_BASE_URL)
        .get(`/customers/`)
        .query({ email: mockedCustomer.email })
        .reply(404, {});

      const response = await fastify.inject({
        method: "GET",
        url: "/shipping-cost",
        query: {
          customerEmail: mockedCustomer.email,
        },
      });
      t.equal(response.statusCode, 404);
      t.same(JSON.parse(response.payload), {
        error: "Customer does not exist",
      });

      getCustomerScope.done();
    });

    t.test("503 - error getting orders count", async (t) => {
      const getCustomerScope = nock(CRUD_BASE_URL)
        .get(`/customers/`)
        .query({ email: mockedCustomer.email })
        .reply(200, [mockedCustomer]);

      const getOrderScope = nock(CRUD_BASE_URL)
        .get(`/orders/count`)
        .query({ customerId: mockedCustomer._id })
        .reply(500, 0);

      const response = await fastify.inject({
        method: "GET",
        url: "/shipping-cost",
        query: {
          customerEmail: mockedCustomer.email,
        },
      });
      t.equal(response.statusCode, 503);
      t.same(JSON.parse(response.payload), {
        error: "Error in Order collection",
      });

      // Check if the mocked requests have been really called by the handler
      getOrderScope.done();
      getCustomerScope.done();
    });

    t.test("New customer shipping cost", async (t) => {
      const getCustomerScope = nock(CRUD_BASE_URL)
        .get(`/customers/`)
        .query({ email: mockedCustomer.email })
        .reply(200, [mockedCustomer]);

      const getOrderScope = nock(CRUD_BASE_URL)
        .get(`/orders/count`)
        .query({ customerId: mockedCustomer._id })
        .reply(200, 0);

      const response = await fastify.inject({
        method: "GET",
        url: "/shipping-cost",
        query: {
          customerEmail: mockedCustomer.email,
        },
      });
      t.equal(response.statusCode, 200);
      t.same(JSON.parse(response.payload), {
        shippingCost: NEW_CUSTOMER_SHIPPING_COST,
      });

      // Check if the mocked requests have been really called by the handler
      getOrderScope.done();
      getCustomerScope.done();
    });

    t.test("Default customer shipping cost", async (t) => {
      const getCustomerScope = nock(CRUD_BASE_URL)
        .get(`/customers/`)
        .query({ email: mockedCustomer.email })
        .reply(200, [mockedCustomer]);

      const getOrderScope = nock(CRUD_BASE_URL)
        .get(`/orders/count`)
        .query({ customerId: mockedCustomer._id })
        .reply(200, 1);

      const response = await fastify.inject({
        method: "GET",
        url: "/shipping-cost",
        query: {
          customerEmail: mockedCustomer.email,
        },
      });
      t.equal(response.statusCode, 200);
      t.same(JSON.parse(response.payload), {
        shippingCost: DEFAULT_SHIPPING_COST,
      });

      // Check if the mocked requests have been really called by the handler
      getOrderScope.done();
      getCustomerScope.done();
    });
    t.end();
  });
});
```

</p>
</details>

</TabItem>
<TabItem value="java">

In this example we will use [wiremock](https://wiremock.org/) package to mock the external calls to the CRUD service simulating responses from HTTP requests and [gson](https://github.com/google/gson) to parse and serialize JSON data. So the first thing we are going to do is to import those packages in the `pom.xml` file under the `dependencies` tag:

```xml
<dependency>
    <groupId>com.github.tomakehurst</groupId>
    <artifactId>wiremock-jre8</artifactId>
    <version>2.35.0</version>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>com.google.code.gson</groupId>
    <artifactId>gson</artifactId>
    <version>2.10.1</version>
</dependency>
```

Now install the new dependencies with [maven cli](https://maven.apache.org/):

```zsh
mvn dependency:resolve
```

Once we have installed the required packages we can create and open the `ShippingControllerTest.java` file at the following path `src/test/java/eu/miaplatform/customplugin/springboot/` in order to write the required test.

:::info
Disclamer: the current example doesn't follow the springboot best practice for simplicity of demonstration. Feel free to refactor the results as you see fit.
:::

```java title=/src/test/java/eu/miaplatform/customplugin/springboot/ShippingControllerTest.java
package eu.miaplatform.customplugin.springboot;

import com.github.tomakehurst.wiremock.client.WireMock;
import com.github.tomakehurst.wiremock.junit5.WireMockTest;
import com.google.gson.Gson;
import eu.miaplatform.customplugin.springboot.models.Customer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.test.context.junit.jupiter.SpringExtension;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;

import static com.github.tomakehurst.wiremock.client.WireMock.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@ExtendWith(SpringExtension.class)
@SpringBootTest
@AutoConfigureMockMvc
@WireMockTest(proxyMode = true, httpPort = 5127)
public class ShippingControllerTest {
    @Autowired
    private MockMvc mvc;
    static final Double NEW_CUSTOMER_SHIPPING_COST = 5.99;
    static final Double DEFAULT_SHIPPING_COST = 10.0;
    static final String CRUD_BASE_URL = "http://crud-service";
    private final Gson gson = new Gson();

     @Test
    public void discountedShippingCost() throws Exception {
        String customerId = "123abc";
        Customer customer = new Customer(customerId, "customer");
        Customer[] crudResponse = {customer};
        int numberOfOrders = 0;

        URL url = new URL(CRUD_BASE_URL);

        stubFor(WireMock.get(urlPathEqualTo("/customers/"))
                .withScheme(url.getProtocol())
                .withHost(WireMock.equalTo(url.getHost()))
                .withQueryParam("email", WireMock.equalTo(customer.getEmail()))
                .willReturn(aResponse()
                        .withHeader("Content-Type", MediaType.APPLICATION_JSON_VALUE)
                        .withBody(gson.toJson(crudResponse))
                )
        );

        stubFor(WireMock.get(urlPathEqualTo("/orders/count"))
                .withScheme(url.getProtocol())
                .withHost(WireMock.equalTo(url.getHost()))
                .withQueryParam("customerId", WireMock.equalTo(customer.get_id()))
                .willReturn(aResponse()
                        .withHeader("Content-Type", MediaType.APPLICATION_JSON_VALUE)
                        .withBody(Integer.toString(numberOfOrders))
                )
        );

        mvc.perform(MockMvcRequestBuilders
                        .get("/shipping-cost")
                        .queryParam("customerEmail", customer.getEmail()))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.shippingCost").value(NEW_CUSTOMER_SHIPPING_COST));
    }
}
```

In this test we tested only the "happy path," that is, returning the correct shipping cost for a new customer. To achieve full coverage by testing the inputs and the return of the default shipping cost you need to write more tests, so if you want to try that or just copy the complete test code below:

<details><summary>Tests to get full coverage:</summary>
<p>

```java title=/src/test/java/eu/miaplatform/customplugin/springboot/ShippingControllerTest.java
package eu.miaplatform.customplugin.springboot;

import com.github.tomakehurst.wiremock.client.WireMock;
import com.github.tomakehurst.wiremock.junit5.WireMockTest;
import com.google.gson.Gson;
import eu.miaplatform.customplugin.springboot.models.Customer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.test.context.junit.jupiter.SpringExtension;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;
import org.springframework.web.server.ResponseStatusException;

import java.net.URL;

import static com.github.tomakehurst.wiremock.client.WireMock.*;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@ExtendWith(SpringExtension.class)
@SpringBootTest
@AutoConfigureMockMvc
@WireMockTest(proxyMode = true, httpPort = 5127)
public class ShippingControllerTest {
    @Autowired
    private MockMvc mvc;
    static final Double NEW_CUSTOMER_SHIPPING_COST = 5.99;
    static final Double DEFAULT_SHIPPING_COST = 10.0;
    static final String CRUD_BASE_URL = "http://crud-service";
    private final Gson gson = new Gson();

    @Test
    public void discountedShippingCost() throws Exception {
        String customerId = "123abc";
        Customer customer = new Customer(customerId, "customer");
        Customer[] crudResponse = {customer};
        int numberOfOrders = 0;

        URL url = new URL(CRUD_BASE_URL);

        stubFor(WireMock.get(urlPathEqualTo("/customers/"))
                .withScheme(url.getProtocol())
                .withHost(WireMock.equalTo(url.getHost()))
                .withQueryParam("email", WireMock.equalTo(customer.getEmail()))
                .willReturn(aResponse()
                        .withHeader("Content-Type", MediaType.APPLICATION_JSON_VALUE)
                        .withBody(gson.toJson(crudResponse))
                )
        );

        stubFor(WireMock.get(urlPathEqualTo("/orders/count"))
                .withScheme(url.getProtocol())
                .withHost(WireMock.equalTo(url.getHost()))
                .withQueryParam("customerId", WireMock.equalTo(customer.get_id()))
                .willReturn(aResponse()
                        .withHeader("Content-Type", MediaType.APPLICATION_JSON_VALUE)
                        .withBody(Integer.toString(numberOfOrders))
                )
        );

        mvc.perform(MockMvcRequestBuilders
                        .get("/shipping-cost")
                        .queryParam("customerEmail", customer.getEmail()))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.shippingCost").value(NEW_CUSTOMER_SHIPPING_COST));
    }

    @Test
    public void defaultShippingCost() throws Exception {
        String customerId = "123abc";
        Customer customer = new Customer(customerId, "customer");
        Customer[] crudResponse = {customer};
        int numberOfOrders = 2;

        URL url = new URL(CRUD_BASE_URL);

        stubFor(WireMock.get(urlPathEqualTo("/customers/"))
                .withScheme(url.getProtocol())
                .withHost(WireMock.equalTo(url.getHost()))
                .withQueryParam("email", WireMock.equalTo(customer.getEmail()))
                .willReturn(aResponse()
                        .withHeader("Content-Type", MediaType.APPLICATION_JSON_VALUE)
                        .withBody(gson.toJson(crudResponse))
                )
        );

        stubFor(WireMock.get(urlPathEqualTo("/orders/count"))
                .withScheme(url.getProtocol())
                .withHost(WireMock.equalTo(url.getHost()))
                .withQueryParam("customerId", WireMock.equalTo(customer.get_id()))
                .willReturn(aResponse()
                        .withHeader("Content-Type", MediaType.APPLICATION_JSON_VALUE)
                        .withBody(Integer.toString(numberOfOrders)))
        );

        mvc.perform(MockMvcRequestBuilders
                        .get("/shipping-cost")
                        .queryParam("customerEmail", customer.getEmail()))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.shippingCost").value(DEFAULT_SHIPPING_COST));
    }

    @Test
    public void noCustomerFound() throws Exception {
        String customerId = "123abc";
        Customer customer = new Customer(customerId, "customer");
        Customer[] crudResponse = {customer};

        URL url = new URL(CRUD_BASE_URL);

        stubFor(WireMock.get(urlPathEqualTo("/customers/"))
                .withScheme(url.getProtocol())
                .withHost(WireMock.equalTo(url.getHost()))
                .withQueryParam("email", WireMock.equalTo(customer.getEmail()))
                .willReturn(aResponse()
                        .withHeader("Content-Type", MediaType.APPLICATION_JSON_VALUE)
                        .withStatus(404)
                        .withBody("{}")
                )
        );

        mvc.perform(MockMvcRequestBuilders
                        .get("/shipping-cost")
                        .queryParam("customerEmail", customer.getEmail()))
                .andExpect(status().isNotFound())
                .andExpect(result -> assertTrue(result.getResolvedException() instanceof ResponseStatusException))
                .andExpect(result -> assertEquals("404 NOT_FOUND \"Customer does not exist\"", result.getResolvedException().getMessage()));
    }

    @Test
    public void errorGetOrdersCount() throws Exception {
        String customerId = "123abc";
        Customer customer = new Customer(customerId, "customer");
        Customer[] crudResponse = {customer};

        URL url = new URL(CRUD_BASE_URL);

        stubFor(WireMock.get(urlPathEqualTo("/customers/"))
                .withScheme(url.getProtocol())
                .withHost(WireMock.equalTo(url.getHost()))
                .withQueryParam("email", WireMock.equalTo(customer.getEmail()))
                .willReturn(aResponse()
                        .withHeader("Content-Type", MediaType.APPLICATION_JSON_VALUE)
                        .withBody(gson.toJson(crudResponse))
                )
        );

        stubFor(WireMock.get(urlPathEqualTo("/orders/count"))
                .withScheme(url.getProtocol())
                .withHost(WireMock.equalTo(url.getHost()))
                .withQueryParam("customerId", WireMock.equalTo(customer.get_id()))
                .willReturn(aResponse()
                        .withHeader("Content-Type", MediaType.APPLICATION_JSON_VALUE)
                        .withStatus(500)
                        .withBody(""))
        );

        mvc.perform(MockMvcRequestBuilders
                        .get("/shipping-cost")
                        .queryParam("customerEmail", customer.getEmail()))
                .andExpect(status().isServiceUnavailable())
                .andExpect(result -> assertTrue(result.getResolvedException() instanceof ResponseStatusException))
                .andExpect(result -> assertEquals("503 SERVICE_UNAVAILABLE \"Invalid orders count\"", result.getResolvedException().getMessage()));
    }
}
```

</p>
</details>

</TabItem>
</Tabs>

### Write the handler

Once we have created the test it's time to write the handler:

<Tabs
  defaultValue="js"
  groupId="microservice-tutorial-language"
  values={[
      { label: 'Node.js', value: 'js', },
      { label: 'Java', value: 'java', },
  ]}
>
<TabItem value="js">

To do this, we need to create and navigate to the `handlers` folder add a new file called `getShippingCost.js`.

As first things first, we define the schema for the request and response:

```js
const schema = {
  querystring: {
    type: "object",
    properties: {
      customerEmail: { type: "string" },
    },
  },
  response: {
    200: {
      type: "object",
      properties: {
        shippingCost: { type: "number" },
      },
    },
    "4xx": {
      type: "object",
      properties: {
        error: { type: "string" },
      },
    },
    "5xx": {
      type: "object",
      properties: {
        error: { type: "string" },
      },
    },
  },
};
```

As written in the schema, the route accepts a `customerEmail` as query string parameter and return the associated shipping cost if all goes well, otherwise it returns an appropriate error response.

Now we need to write the manager itself for:

1. Read from CRUD `customers` to retrive the `_id` of the customer related to the mail;
1. Read from CRUD `orders` to count the number of orders placed by the customer;
1. Return the shipping cost, if it is the first order the shipping will be less.

The handler code will be the following:

```js
async function handler(req, rep) {
  const DEFAULT_SHIPPING_COST = 10;
  const NEW_CUSTOMER_SHIPPING_COST = 5.99;
  const CRUD_BASE_URL = "http://crud-service/";
  // Get proxy to interact with the CRUD Service
  const proxy = req.getHttpClient(CRUD_BASE_URL);

  // Get query params
  const { customerEmail } = req.query;

  let customerCrudRes;
  try {
    customerCrudRes = await proxy.get(`/customers/`, {
      query: { email: customerEmail },
    });
  } catch (error) {
    return rep.code(404).send({ error: "Customer does not exist" });
  }

  const [customer] = customerCrudRes.payload;

  let orderCrudRes;
  try {
    orderCrudRes = await proxy.get(`/orders/count`, {
      query: { customerId: customer._id },
    });
  } catch (error) {
    return rep.code(503).send({ error: "Error in Order collection" });
  }

  const numberOfOrders = orderCrudRes.payload;

  const shippingCost =
    numberOfOrders > 0 ? DEFAULT_SHIPPING_COST : NEW_CUSTOMER_SHIPPING_COST;

  return rep.code(200).send({ shippingCost });
}
```

As you can see the function offered by the CustomPluginLib `getHttpClient` is used, this is needed to get a proxy to make calls to the CRUD service API allowing internal cluster hostnames to be resolved, as in this case `crud-service` it is the microservice hostname inside the cluster.

:::info CRUD Service
To take in deeper how to use API exposed by the CRUD Service check out the [CRUD Endpoints Documentation](/runtime_suite/crud-service/overview_and_usage.md#crud-endpoints)
:::

The last thing left to do is to export the function:

```js
module.exports = {
  handler,
  schema,
};
```

<details><summary>Complete snippet:</summary>
<p>

```js title=/handlers/getShippingCost.js
"use strict";

const schema = {
  querystring: {
    type: "object",
    properties: {
      customerEmail: { type: "string" },
    },
  },
  response: {
    200: {
      type: "object",
      properties: {
        shippingCost: { type: "number" },
      },
    },
    "4xx": {
      type: "object",
      properties: {
        error: { type: "string" },
      },
    },
    "5xx": {
      type: "object",
      properties: {
        error: { type: "string" },
      },
    },
  },
};

async function handler(req, rep) {
  const DEFAULT_SHIPPING_COST = 10;
  const NEW_CUSTOMER_SHIPPING_COST = 5.99;
  const CRUD_BASE_URL = "http://crud-service/";
  // Get proxy to interact with the CRUD Service
  const proxy = req.getHttpClient(CRUD_BASE_URL);

  // Get query params
  const { customerEmail } = req.query;

  let customerCrudRes;
  try {
    customerCrudRes = await proxy.get(`/customers/`, {
      query: { email: customerEmail },
    });
  } catch (error) {
    return rep.code(404).send({ error: "Customer does not exist" });
  }

  const [customer] = customerCrudRes.payload;

  let orderCrudRes;
  try {
    orderCrudRes = await proxy.get(`/orders/count`, {
      query: { customerId: customer._id },
    });
  } catch (error) {
    return rep.code(503).send({ error: "Error in Order collection" });
  }

  const numberOfOrders = orderCrudRes.payload;

  const shippingCost =
    numberOfOrders > 0 ? DEFAULT_SHIPPING_COST : NEW_CUSTOMER_SHIPPING_COST;

  return rep.code(200).send({ shippingCost });
}

module.exports = {
  handler,
  schema,
};
```

</p>
</details>

</TabItem>
<TabItem value="java">

First we need to create the classes that will represent the data models we are going to use, which will be `shipping` and `customer`. To do this create the package `eu.miaplatform.customplugin.springboot.models` and inside we are going to create the classes.

The `Shipping` class will be:

```java title="/src/main/java/eu/miaplatform/customplugin/springboot/models/Shipping.java"
package eu.miaplatform.customplugin.springboot.models;

public class Shipping {
    public Double shippingCost;

    public Shipping() {}

    public Shipping(Double shippingCost) {
        this.shippingCost = shippingCost;
    }
}
```

While the `customer` class will be:

```java title="/src/main/java/eu/miaplatform/customplugin/springboot/models/Customer.java"
package eu.miaplatform.customplugin.springboot.models;

public class Customer {
    String _id;
    String email;

    public Customer() {}

    public Customer(String _id, String email) {
        this._id = _id;
        this.email = email;
    }

    public String get_id() {
        return _id;
    }

    public String getEmail() {
        return email;
    }
}

```

And finally we are ready to write the handler. It will acepts a `customerEmail` as query string parameter and return the associated shipping cost if all goes well, otherwise it returns an appropriate error response.

Now we need to write the manager itself for:

1. Read from CRUD `customers` to retrive the `_id` of the customer related to the mail;
1. Read from CRUD `orders` to count the number of orders placed by the customer;
1. Return the shipping cost, if it is the first order the shipping will be less.

The handler code will be the following:

```java title="/src/main/java/eu/miaplatform/customplugin/springboot/controllers/ShippingController.java"
package eu.miaplatform.customplugin.springboot.controllers;

import com.google.gson.Gson;
import eu.miaplatform.customplugin.ServiceClientFactory;
import eu.miaplatform.customplugin.springboot.models.Customer;
import eu.miaplatform.customplugin.springboot.models.Shipping;
import eu.miaplatform.service.InitServiceOptions;
import eu.miaplatform.service.Protocol;
import eu.miaplatform.service.Service;
import okhttp3.Response;
import org.springframework.http.HttpStatus;
import org.springframework.web.server.ResponseStatusException;

import java.io.IOException;
import java.net.URL;
import java.util.HashMap;

public class ShippingController {
    static final Double NEW_CUSTOMER_SHIPPING_COST = 5.99;
    static final Double DEFAULT_SHIPPING_COST = 10.0;
    static final String CRUD_BASE_URL = "http://crud-service";

    static final Gson gson = new Gson();

    public Shipping getShippingCost(String customerEmail) throws IOException {
        URL url = new URL(CRUD_BASE_URL);
        Protocol protocol = url.getProtocol().equals("https") ? Protocol.HTTPS : Protocol.HTTP;
        int port = url.getPort() > 0 ? url.getPort() : 3000;

        InitServiceOptions serviceOptions = new InitServiceOptions(url.getPort(), protocol, new HashMap<>(),  url.getPath());
        Service serviceClient = ServiceClientFactory.getDirectServiceProxy(url.getHost(), serviceOptions);

        Customer customer;
        try {
            Response customerResponse = serviceClient.get("/customers/",
                    String.format("email=%s", customerEmail),
                    null);
            okhttp3.ResponseBody customerResponseBody = customerResponse.body();
            if (customerResponse.code() != HttpStatus.OK.value() || customerResponseBody == null) throw new Exception();
            String customerString = customerResponseBody.string();
            customer = gson.fromJson(customerString, Customer[].class)[0];
        } catch (Exception e) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND, "Customer does not exist");
        }

        Integer numberOfOrders;
        try {
            Response ordersCountResponse = serviceClient.get("/orders/count",
                    String.format("customerId=%s", customer.get_id()),
                    null);
            okhttp3.ResponseBody ordersCountBody = ordersCountResponse.body();
            if (ordersCountResponse.code() != HttpStatus.OK.value() || ordersCountBody == null) throw new Exception();
            String ordersCountString = ordersCountBody.string();
            numberOfOrders = gson.fromJson(ordersCountString, Integer.class);
        } catch (Exception e) {
            throw new ResponseStatusException(HttpStatus.SERVICE_UNAVAILABLE, "Invalid orders count");
        }

        if (numberOfOrders == 0)
            return new Shipping(NEW_CUSTOMER_SHIPPING_COST);

        return new Shipping(DEFAULT_SHIPPING_COST);
    }

}
```

As you can see the function offered by the customplugin `getDirectServiceProxy` is used, this is needed to get a proxy to make calls to the CRUD service API allowing internal cluster hostnames to be resolved, as in this case `crud-service` it is the microservice hostname inside the cluster.

:::info CRUD Service
To take in deeper how to use API exposed by the CRUD Service check out the [CRUD Endpoints Documentation](/runtime_suite/crud-service/overview_and_usage.md#crud-endpoints)
:::

</TabItem>
</Tabs>

### Add the route

<Tabs
  defaultValue="js"
  groupId="microservice-tutorial-language"
  values={[
      { label: 'Node.js', value: 'js', },
      { label: 'Java', value: 'java', },
  ]}
>
<TabItem value="js">

The last thing to do in the service is to register the route, to do so go back to `index.js` file and add the route `GET /shipping-cost` handled by the function written previously:

```js title=index.js
"use strict";

const customService = require("@mia-platform/custom-plugin-lib")();
const getShippingCost = require("./handlers/getShippingCost");

module.exports = customService(async function index(service) {
  service.addRawCustomPlugin(
    "GET",
    "/shipping-cost",
    getShippingCost.handler,
    getShippingCost.schema
  );
});
```

Now run tests implemented previously by the properly NPM script command:

```zsh
npm run test
```

Finally commit and push changes to master.

:::caution
As previously mentioned Mia-Platform cares about TDD programming so you will not be able to commit until 100% coverage is reached, to check the current coverage you can run:

```zsh
npm run coverage
```

:::

</TabItem>
<TabItem value="java">

The last thing to do is to decorate the function to register it with spring:

```java {24-25,33-36} title="/src/main/java/eu/miaplatform/customplugin/springboot/controllers/ShippingController.java"
package eu.miaplatform.customplugin.springboot.controllers;

import com.google.gson.Gson;
import eu.miaplatform.customplugin.ServiceClientFactory;
import eu.miaplatform.customplugin.springboot.models.Customer;
import eu.miaplatform.customplugin.springboot.models.Shipping;
import eu.miaplatform.service.InitServiceOptions;
import eu.miaplatform.service.Protocol;
import eu.miaplatform.service.Service;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import okhttp3.Response;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.server.ResponseStatusException;

import java.io.IOException;
import java.net.URL;
import java.util.HashMap;

@RestController
@Api(value = "ShippingController")
public class ShippingController {
    static final Double NEW_CUSTOMER_SHIPPING_COST = 5.99;
    static final Double DEFAULT_SHIPPING_COST = 10.0;
    static final String CRUD_BASE_URL = "http://crud-service:5127";

    static final Gson gson = new Gson();

    @GetMapping("/shipping-cost")
    @ApiOperation(value = "shipping")
    @ResponseBody
    public Shipping getShippingCost(@RequestParam("customerEmail") String customerEmail) throws IOException {
        URL url = new URL(CRUD_BASE_URL);
        Protocol protocol = url.getProtocol().equals("https") ? Protocol.HTTPS : Protocol.HTTP;
        int port = url.getPort() > 0 ? url.getPort() : 3000;

        InitServiceOptions serviceOptions = new InitServiceOptions(url.getPort(), protocol, new HashMap<>(),  url.getPath());
        Service serviceClient = ServiceClientFactory.getDirectServiceProxy(url.getHost(), serviceOptions);

        Customer customer;
        try {
            Response customerResponse = serviceClient.get("/customers/",
                    String.format("email=%s", customerEmail),
                    null);
            okhttp3.ResponseBody customerResponseBody = customerResponse.body();
            if (customerResponse.code() != HttpStatus.OK.value() || customerResponseBody == null) throw new Exception();
            String customerString = customerResponseBody.string();
            customer = gson.fromJson(customerString, Customer[].class)[0];
        } catch (Exception e) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND, "Customer does not exist");
        }

        Integer numberOfOrders;
        try {
            Response ordersCountResponse = serviceClient.get("/orders/count",
                    String.format("customerId=%s", customer.get_id()),
                    null);
            okhttp3.ResponseBody ordersCountBody = ordersCountResponse.body();
            if (ordersCountResponse.code() != HttpStatus.OK.value() || ordersCountBody == null) throw new Exception();
            String ordersCountString = ordersCountBody.string();
            numberOfOrders = gson.fromJson(ordersCountString, Integer.class);
        } catch (Exception e) {
            throw new ResponseStatusException(HttpStatus.SERVICE_UNAVAILABLE, "Invalid orders count");
        }

        if (numberOfOrders == 0)
            return new Shipping(NEW_CUSTOMER_SHIPPING_COST);

        return new Shipping(DEFAULT_SHIPPING_COST);
    }

}

```

Now run tests implemented previously by the properly Maven script command:

```zsh
mvn test
```

Finally commit and push changes to master.

</TabItem>
</Tabs>

## Try the Microservice

Now we can [deploy](/tutorial/console/console_handbook.md#deploy-changes) the service, so we can test it. Be careful to flag the "Always release services not following semantic versioning" checkbox, we will see the semantic versioning later in the tutorial.

After the deploy has been finished, open the [API Portal](/runtime_suite/api-portal/overview.md) and use the _Customers_ CRUD routes to add this document:

<details><summary>Click to see the customer schema:</summary>
<p>

```json
{
  "name": "Awesome",
  "surname": "Customer",
  "email": "awesome.customer@email.com",
  "phone": 1234567890
}
```

</p>
</details>

Now you can try the `GET /shipping-cost` route and you will see that it will return the `NEW_CUSTOMER_SHIPPING_COST` value which will be 5.99, if you followed the tutorial.

Now use the _Orders_ CRUD routes to add this document:

<details><summary>Click to see the orders schema:</summary>
<p>

```json
{
  "customerId": "<_id>",
  "productId": 1234,
  "quantity": 2,
  "expectedShipmentDate": "2023-10-10",
  "statusHistory": ["received"]
}
```

</p>
</details>

:::caution
Get the response \_id from the creation of the client and replace the `"<_id>"` placeholder in `customerId` in the previous json.
:::

Now if you try again the `GET /shipping-cost` route you will see that it will return the `DEFAULT_SHIPPING_COST` value which will be 10, because it will be the second order.

## Environment variable

You should know, as a developer, that writing values directly into the code it isn't a good practice, so we want to extract the `CRUD_BASE_URL`, `DEFAULT_SHIPPING_COST` and `NEW_CUSTOMER_SHIPPING_COST` variables as [environment variables](/development_suite/set-up-infrastructure/env-var-intro.md).

An environment variable is a variable whose value is set outside the microservices made up of a name/value pair. You can set a different value based on the environment (Development, Production, etc.).

### Create an environment variable

In order to do this follow these steps:

1. Open your project in Mia-Platform Console;
1. Go to _Project Settings_ section;
1. Click on _Environments_ tab and click _Add new runtime environment_;
1. Create the `CRUD_BASE_URL`:
   1. Insert the key `DEV_CRUD_BASE_URL` and enter `http://crud-service` as value;
   1. Insert the key `PROD_CRUD_BASE_URL` and enter `http://crud-service-production` as value;

In this way, we have created the `CRUD_BASE_URL` that values `http://crud-service` in the _Development_ environment and `http://crud-service-production` for _Production_, so as to use different cruds based on the environment to increase segregation.

:::info
Using `MIA_` as a prefix in the ENV you will set the value for all environments
:::

### Add the ENV to the microservice

Now we have to add the environment variable to the microservice:

1. Go to _Microservices_ and select the _get-shipping-cost_ service.
1. Go to section _Environment variable configuration_ click _Add Environment Variable_
1. Create the `DEFAULT_SHIPPING_COST` and enter `12` as value;
1. Create the `NEW_CUSTOMER_SHIPPING_COST` and enter `7` as value;
1. Insert the key `CRUD_BASE_URL` and `{{CRUD_BASE_URL}}` as value.
1. Commit the changes

In this way the microservice can access to `CRUD_BASE_URL` ENV. Using `{{env_name}}` Mia-Platform automatically interpolates the correct value for each environment where the microservice will run.

### Edit microservice

Now we need to modify the microservice so that it uses environment variabiles.

<Tabs
  defaultValue="js"
  groupId="microservice-tutorial-language"
  values={[
      { label: 'Node.js', value: 'js', },
      { label: 'Java', value: 'java', },
  ]}
>
<TabItem value="js">

As the first thing adjust the tests in `/tests/index.test.js` file injecting the variables in the `setupFastify` method:

```js {9-11}
t.test('shipping-cost', async t => {
  // silent => trace to enable logs
  const fastify = await setupFastify({
    USERID_HEADER_KEY: 'userid',
    GROUPS_HEADER_KEY: 'groups',
    CLIENTTYPE_HEADER_KEY: 'clienttype',
    BACKOFFICE_HEADER_KEY: 'backoffice',
    MICROSERVICE_GATEWAY_SERVICE_NAME: 'microservice-gateway.example.org',
    NEW_CUSTOMER_SHIPPING_COST,
    DEFAULT_SHIPPING_COST,
    CRUD_BASE_URL,
  })
  ...
}
```

After we have to edit `index.js` and set the schema of the environment variables used by the microservice:

```js
...
const customService = require("@mia-platform/custom-plugin-lib")({
  type: "object",
  required: [
    "CRUD_BASE_URL",
    "DEFAULT_SHIPPING_COST",
    "NEW_CUSTOMER_SHIPPING_COST",
  ],
  properties: {
    CRUD_BASE_URL: {
      type: "string",
      description: "Base url where CRUD exposes its APIs",
    },
    DEFAULT_SHIPPING_COST: {
      type: "number",
      description: "Default shipping cost",
    },
    NEW_CUSTOMER_SHIPPING_COST: {
      type: "number",
      description: "Shipping cost for new clients",
    },
  },
});
...
```

Finally change the `/handlers/getShippingCost.js` handler in order to use the ENV, this will be available under `config` property of the request:

```js
async function handler(req, reply) {
  const { NEW_CUSTOMER_SHIPPING_COST, DEFAULT_SHIPPING_COST, CRUD_BASE_URL } = this.config
  req.log.info({ value: CRUD_BASE_URL }, 'CRUD_BASE_URL value')
  req.log.info({ value: DEFAULT_SHIPPING_COST }, 'DEFAULT_SHIPPING_COST value')
  req.log.info({ value: NEW_CUSTOMER_SHIPPING_COST }, 'NEW_CUSTOMER_SHIPPING_COST value')
  // Get proxy to interact with the CRUD Service
  const proxy = req.getHttpClient(CRUD_BASE_URL)

  ...
}
```

Furthermore we will log the value of the ENV.

:::info Logging
Check out the [Guidelines for logs](/getting_started/monitoring-dashboard/dev_ops_guide/log.md) for more details about the log instance.
:::

Now you can commit and push the code to the master branch.

</TabItem>
<TabItem value="java">

First of all we want to create test-specific variables, so we create the file `application-test.proprieties` and enter the default variables:

```title="/src/main/java/resources/application-test.properties"
constants.shipping.new=5.99
constants.shipping.default=10
constants.crud.url=http://crud-service:5127
```

And update also the tests:

```java {8,13-18} title=/src/test/java/eu/miaplatform/customplugin/springboot/ShippingControllerTest.java
package eu.miaplatform.customplugin.springboot;

...

@ExtendWith(SpringExtension.class)
@SpringBootTest
@AutoConfigureMockMvc
@TestPropertySource(locations = "/application-test.properties")
@WireMockTest(proxyMode = true, httpPort = 5127)
public class ShippingControllerTest {
    @Autowired
    private MockMvc mvc;
    @Value("${constants.shipping.new}")
    private Double NEW_CUSTOMER_SHIPPING_COST;
    @Value("${constants.shipping.default}")
    private Double DEFAULT_SHIPPING_COST;
    @Value("${constants.crud.url}")
    private String CRUD_BASE_URL;

    private final Gson gson = new Gson();

     @Test
    public void discountedShippingCost() throws Exception {
      ...
    }
}
```

We need also to add the variabiles to the `application.properties` in order to make the environment variabiles accessible to spring handler:

```title="/src/main/java/resources/application.properties"
constants.shipping.new=${NEW_CUSTOMER_SHIPPING_COST}
constants.shipping.default=${DEFAULT_SHIPPING_COST}
constants.crud.url=${CRUD_BASE_URL}
```

And finally we update the handler to use the variabiles:

```java {13,28-33} title="/src/main/java/eu/miaplatform/customplugin/springboot/controllers/ShippingController.java"
package eu.miaplatform.customplugin.springboot.controllers;

import com.google.gson.Gson;
import eu.miaplatform.customplugin.ServiceClientFactory;
import eu.miaplatform.customplugin.springboot.models.Customer;
import eu.miaplatform.customplugin.springboot.models.Shipping;
import eu.miaplatform.service.InitServiceOptions;
import eu.miaplatform.service.Protocol;
import eu.miaplatform.service.Service;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import okhttp3.Response;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.server.ResponseStatusException;

import java.io.IOException;
import java.net.URL;
import java.util.HashMap;

@RestController
@Api(value = "ShippingController")
public class ShippingController {
    @Value("${constants.shipping.new}")
    private Double NEW_CUSTOMER_SHIPPING_COST;
    @Value("${constants.shipping.default}")
    private Double DEFAULT_SHIPPING_COST;
    @Value("${constants.crud.url}")
    private String CRUD_BASE_URL;

    static final Gson gson = new Gson();

    @GetMapping("/shipping-cost")
    @ApiOperation(value = "shipping")
    @ResponseBody
    public Shipping getShippingCost(@RequestParam("customerEmail") String customerEmail) throws IOException {
      ...
    }
}
```

Now you can commit and push the code to the master branch.

</TabItem>
</Tabs>

## Final test

Now we can deploy the project to try the microservice.

After the deploy open the [Documentation Portal](/development_suite/api-portal/api-documentations.md) and try the `GET /shipping-cost` route, it will return the new values:

![API Portal try /shipping-cost](img/node-ms-api-portal-final-test.gif)

## Health routes

Let's go back to the Console, specifically go to the microservice detail page. You can see several configuration fields (check out this [page](/development_suite/api-console/api-design/services.md#manage-microservices) for more details), in particular the _probes_ section define the [health routes](/guidelines/microservice_vademecum.md#health-routes) for the Kubernetes pod:

- The _Readiness path_ provides k8s with information about when the container is ready to receive incoming traffic. The default route is `/-/ready`.
- The _Liveness path_ provides k8s with information about when the container is in a healthy state. The default route is `/-/healthz`.

These routes are called automatically by Kubernetes and the microservice you just created has a default implementation provided by the Mia-Platform custom plugin libs: [Node.js](https://github.com/mia-platform/custom-plugin-lib), [Go](https://github.com/mia-platform/configlib) and [Java](https://github.com/mia-platform/custom-plugin-java-springboot) implementations.

:::info
Check out [Kubernetes official documentation](https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/) for more details about probes.
:::

Those information are shown also in the runtime section to know if a service is healthy or not.

## Runtime

In this tutorial, we have created a microservice perfectly integrated with Mia-Platform Console, as the last step, we will find out how to monitor microservices logs:

1. From your project, go to section _Runtime_.
1. From here, you can see select the environment and see the list of current running pods. Select _Development_ as environment and search for `get-shipping-cost-...` pod.
1. Click on the pod name to see all logs. Here you should see the logs with the value of the `CRUD_BASE_URL`, `DEFAULT_SHIPPING_COST` and `NEW_CUSTOMER_SHIPPING_COST` environmental variables.

![Microservice logs](img/node-ms-log.gif)

## Tag and deploy the first release

Now the last thing to do is to use semantic versioning on the console release, so after those changes we are ready to tag this version.

To do so:

- Open the _design_ section;
- In the upper right-corner open the git section;
- Click the tag icon;
- In the form:
  - **Create from**: `master`;
  - **Tag name**: `v0.1.0`;
  - **Short description**: `first project release`.
- Click the _create tag_ button.

Now to deploy it go to the _Deploy_ section, select the tag `v0.1.0` and deploy!

## Microservice repository

You can access the complete repository of the tutorial [here](https://github.com/mia-platform/Node.js-Microservice-Tutorial).
